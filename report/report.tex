\documentclass[acmtog]{acmart}
\usepackage{graphicx}
\usepackage{subfigure}
\usepackage{natbib}
\usepackage{listings}
\usepackage{bm}
\usepackage{amsmath}

\definecolor{blve}{rgb}{0.3372549 , 0.61176471, 0.83921569}
\definecolor{gr33n}{rgb}{0.29019608, 0.7372549, 0.64705882}
\makeatletter
\lst@InstallKeywords k{class}{classstyle}\slshape{classstyle}{}ld
\makeatother
\lstset{language=C++,
	basicstyle=\ttfamily,
	keywordstyle=\color{blve}\ttfamily,
	stringstyle=\color{red}\ttfamily,
	commentstyle=\color{magenta}\ttfamily,
	morecomment=[l][\color{magenta}]{\#},
	classstyle = \bfseries\color{gr33n}, 
	tabsize=2
}
\lstset{basicstyle=\ttfamily}

% Title portion
\title{Assignment 3:\\ {Ray Tracing}} 

\author{Name: tangzhihao \\ student number:2022533131\
\\email: \quad \texttt{tangzhh2022@shanghaitech.edu.cn}}

% Document starts
\begin{document}
\maketitle

\vspace*{2 ex}

\section{Introduction}

This report presents the implementation of a ray tracing renderer with various advanced features. The project successfully implements all required functionalities including ray-geometry intersection, BVH acceleration structure, perfect refraction material, direct lighting, and anti-aliasing. Additionally, several optional features have been implemented, including multiple light sources support, rectangular area lights with soft shadows, environment lighting via environment maps, and texture mapping support.

\section{Implementation Details}

\subsection{Must Requirements}

\subsubsection{Compilation and Language Server [5\%]}
The project has been successfully compiled using CMake build system. The \texttt{clangd} language server has been configured for code navigation and IntelliSense support. The \texttt{compile\_commands.json} file is generated automatically during the build process for language server integration.

\subsubsection{Ray-Triangle Intersection [10\%]}
Implemented in \texttt{src/accel.cpp}, the ray-triangle intersection uses the M\"{o}ller-Trumbore algorithm. The implementation:
\begin{itemize}
    \item Computes barycentric coordinates $(u, v)$ and ray parameter $t$
    \item Performs early exit for parallel rays or invalid intersections
    \item Validates intersection within ray bounds: $u \geq 0, v \geq 0, u + v \leq 1$
    \item Uses double precision for numerical stability
    \item Calculates triangle differentials for texture coordinate interpolation
\end{itemize}

Key code snippet:
\begin{lstlisting}[language=C++]
InternalVecType edge1 = v1 - v0;
InternalVecType edge2 = v2 - v0;
InternalVecType h = Cross(dir, edge2);
InternalScalarType a = Dot(edge1, h);
if (a > -1e-8 && a < 1e-8)
    return false;  // Parallel ray
InternalScalarType f = 1.0 / a;
InternalVecType s = ray.origin - v0;
InternalScalarType u = f * Dot(s, h);
\end{lstlisting}

\subsubsection{Ray-AABB Intersection [10\%]}
Implemented in \texttt{src/accel.cpp} using the slab method. The implementation:
\begin{itemize}
    \item Computes intersection intervals for each axis independently
    \item Uses safe inverse direction to handle edge cases
    \item Correctly handles rays with negative direction components
    \item Clips intersection interval with ray's valid range
    \item Returns entry and exit times via output pointers
\end{itemize}

\begin{lstlisting}[language=C++]
Vec3f t_min_vec = (low_bnd - ray.origin) * 
                  ray.safe_inverse_direction;
Vec3f t_max_vec = (upper_bnd - ray.origin) * 
                  ray.safe_inverse_direction;
Vec3f t_near = Min(t_min_vec, t_max_vec);
Vec3f t_far = Max(t_min_vec, t_max_vec);
Float t_enter = ReduceMax(t_near);
Float t_exit = ReduceMin(t_far);
\end{lstlisting}

\subsubsection{BVH Construction [25\%]}
The BVH (Bounding Volume Hierarchy) construction is implemented in \texttt{src/bvh\_accel.cpp}. The implementation uses a recursive tree structure with:
\begin{itemize}
    \item Surface Area Heuristic (SAH) for optimal split selection
    \item Efficient traversal using stack-based approach
    \item Support for both custom BVH and Embree-accelerated version
    \item Proper AABB computation and triangle primitive handling
\end{itemize}

The BVH significantly accelerates ray-scene intersection tests from $O(n)$ to $O(\log n)$ complexity.

\subsubsection{IntersectionTestIntegrator and PerfectRefraction [25\%]}
Implemented in \texttt{src/integrator.cpp} and \texttt{src/bsdf.cpp}:

\textbf{IntersectionTestIntegrator:}
\begin{itemize}
    \item Traces rays through the scene handling both diffuse and refractive surfaces
    \item Implements direct lighting computation with shadow testing
    \item Supports multi-bounce refraction paths before reaching diffuse surfaces
    \item Uses RTTI to distinguish between material types
\end{itemize}

\textbf{PerfectRefraction Material:}
\begin{itemize}
    \item Implements Snell's law for refraction direction calculation
    \item Handles total internal reflection by falling back to specular reflection
    \item Correctly orients surface normal based on ray direction (entering/exiting)
    \item Uses the \texttt{Refract} utility function for physically accurate direction computation
\end{itemize}

\begin{lstlisting}[language=C++]
Vec3f n_oriented = entering ? normal : -normal;
bool refracted = Refract(-interaction.wo, 
                         n_oriented, 
                         eta_corrected, wt);
if (refracted) {
    interaction.wi = wt;
} else {
    // Total internal reflection
    interaction.wi = Reflect(interaction.wo, 
                             n_oriented);
}
\end{lstlisting}

\subsubsection{Direct Lighting with Shadow Testing [20\%]}
Implemented in \texttt{IntersectionTestIntegrator::directLighting()}:
\begin{itemize}
    \item Computes direct illumination from point light sources
    \item Performs visibility testing using shadow rays
    \item Implements Lambert's cosine law for diffuse BRDF
    \item Includes distance-based light attenuation
    \item Handles occlusion with epsilon tolerance for numerical stability
\end{itemize}

\begin{lstlisting}[language=C++]
Vec3f light_dir = Normalize(point_light_position - 
                            interaction.p);
Ray shadow_ray = interaction.spawnRayTo(
                     point_light_position);
bool blocked = scene->intersect(shadow_ray, shadow_it);
if (blocked && hit_dist + 1e-4F < dist_to_light) {
    return Vec3f(0.0F);  // In shadow
}
Float cos_theta = max(Dot(light_dir, 
                          interaction.normal), 0.0F);
color = point_light_flux * albedo * 
        cos_theta * inv_r2;
\end{lstlisting}

\subsubsection{Anti-Aliasing via Multi-Ray Sampling [5\%]}
Implemented in the render loop with stratified sampling:
\begin{itemize}
    \item Multiple samples per pixel (configurable SPP)
    \item Random sub-pixel jittering within pixel aperture
    \item Sample accumulation in film with proper weighting
    \item Uses \texttt{Sampler::getPixelSample()} for uniform distribution
\end{itemize}

\begin{lstlisting}[language=C++]
for (int sample = 0; sample < spp; sample++) {
    const Vec2f pixel_sample = 
        sampler.getPixelSample();
    auto ray = camera->generateDifferentialRay(
        pixel_sample.x, pixel_sample.y);
    const Vec3f L = Li(scene, ray, sampler);
    camera->getFilm()->commitSample(
        pixel_sample, L);
}
\end{lstlisting}

\subsection{Optional Features}

\subsubsection{Multiple Light Sources Support [5\%]}
The renderer supports multiple light sources through:
\begin{itemize}
    \item Scene-level light management via \texttt{Scene::lights} vector
    \item Iteration over all lights in direct lighting computation
    \item Proper light sampling and PDF computation
    \item Energy-based light selection for efficient rendering
\end{itemize}

\subsubsection{Rectangular Area Lights with Soft Shadows [15\%]}
Implemented via the \texttt{AreaLight} class in \texttt{src/light.cpp}:
\begin{itemize}
    \item Area light geometry defined by rectangular shapes
    \item Uniform sampling over light surface area
    \item Proper PDF computation in solid angle measure
    \item Cosine-weighted emission for physically-based lighting
    \item Naturally produces soft shadows through spatial sampling
\end{itemize}

The \texttt{Rect} shape class provides the geometric primitives for area lights, supporting arbitrary orientation through transformation matrices.

\subsubsection{Environment Lighting via Environment Maps [15\%]}
Implemented through \texttt{InfiniteAreaLight} class in \texttt{src/light.cpp}:

\textbf{Key Features:}
\begin{itemize}
    \item Spherical mapping from 3D directions to 2D texture coordinates
    \item Importance sampling based on environment map luminance distribution
    \item Proper PDF computation with Jacobian transformation: $\text{pdf} = \text{pdf}_{uv} / (2\pi^2 \sin\theta)$
    \item Support for HDR/EXR environment maps with high dynamic range
    \item Transformation support for environment map rotation
    \item Efficient 2D distribution table (\texttt{Distribution2D}) for sampling
\end{itemize}

\textbf{Implementation Details:}
\begin{lstlisting}[language=C++]
Vec3f InfiniteAreaLight::Le(
    const SurfaceInteraction &interaction, 
    const Vec3f &w) const {
    Vec2f scoord = InverseSphericalDirection(
        dirWorldToLocal(-w));
    Vec2f uv(scoord[1]/(2.0*PI), scoord[0]/PI);
    auto new_interaction = interaction;
    new_interaction.setUV(uv);
    return texture->evaluate(new_interaction) 
           * scale;
}
\end{lstlisting}

The preprocessing stage builds a 2D probability distribution weighted by luminance and $\sin\theta$ to account for spherical coordinate non-uniformity:

\begin{lstlisting}[language=C++]
void InfiniteAreaLight::preprocess(
    const PreprocessContext &context) {
    for (int v = 0; v < height; ++v) {
        Float sinTheta = std::sin(PI * vp);
        for (int u = 0; u < width; ++u) {
            Float val = 0.2126f * data[4*index] + 
                       0.7152f * data[4*index+1] + 
                       0.0722f * data[4*index+2];
            img[index] = val * sinTheta;
        }
    }
    distribution = make_ref<Distribution2D>(
        img.data(), width, height);
}
\end{lstlisting}

\subsubsection{Texture Mapping Support Investigation [10\%]}

\textbf{1. Texture Mapping Function in Path Integrator:}

Texture mapping occurs in the \texttt{IdealDiffusion::evaluate()} function (\texttt{src/bsdf.cpp}), which is called from the path integrator when evaluating BRDF:

\begin{lstlisting}[language=C++]
Vec3f IdealDiffusion::evaluate(
    SurfaceInteraction &interaction) const {
    return texture->evaluate(interaction) * INV_PI;
}
\end{lstlisting}

The call chain is: Path Integrator $\rightarrow$ \texttt{bsdf->evaluate()} $\rightarrow$ \texttt{texture->evaluate()} $\rightarrow$ \texttt{mipmap->LookUp()}

\textbf{2. MIPMap Support:}

Texture mapping supports mipmapping through the \texttt{MIPMap} class in \texttt{src/mipmap.cpp}. The implementation includes:

\begin{itemize}
    \item Pre-computed image pyramid with multiple resolution levels
    \item Trilinear interpolation or EWA (Elliptical Weighted Average) filtering
    \item Automatic level selection based on texture coordinate differentials
    \item Anti-aliasing through proper pre-filtering
\end{itemize}

The level selection uses differentials to measure screen-space texture footprint:

\begin{lstlisting}[language=C++]
Vec2f UVMapping2D::Map(
    const SurfaceInteraction &interaction, 
    Vec2f &dstdx, Vec2f &dstdy) const {
    dstdx = scale * Vec2f(interaction.dudx, 
                          interaction.dvdx);
    dstdy = scale * Vec2f(interaction.dudy, 
                          interaction.dvdy);
    return scale * interaction.uv + delta;
}
\end{lstlisting}

\textbf{3. Sphere UV Coordinates and Differentials:}

For spheres, UV coordinates are computed using spherical coordinates in \texttt{src/shape.cpp}:

\begin{lstlisting}[language=C++]
InternalScalarType phi = std::atan2(delta_p.y, 
                                    delta_p.x);
if (phi < 0) phi += 2 * PI;
InternalScalarType theta = std::acos(delta_p.z / 
                                     radius);
InternalScalarType u = phi / (2*PI);  // [0,1]
InternalScalarType v = theta / PI;    // [0,1]
\end{lstlisting}

\textbf{Computed UV Coordinates:}
\begin{itemize}
    \item $u = \phi/(2\pi) \in [0,1]$: Azimuthal angle, wraps around equator
    \item $v = \theta/\pi \in [0,1]$: Polar angle, from north pole ($v=0$) to south pole ($v=1$)
\end{itemize}

\textbf{Why Differentials are Needed:}

Differentials ($\frac{\partial u}{\partial x}, \frac{\partial v}{\partial x}, \frac{\partial u}{\partial y}, \frac{\partial v}{\partial y}$) are essential for:

\begin{enumerate}
    \item \textbf{Anti-aliasing}: Measure how much texture space is covered by a single screen pixel
    \item \textbf{MIPMap level selection}: High differentials (grazing angles) $\rightarrow$ higher mipmap level (pre-filtered); Low differentials (direct view) $\rightarrow$ lower level (detailed)
    \item \textbf{Preventing aliasing}: Without differentials, distant or grazing-angle textures would alias severely
\end{enumerate}

The differentials are computed by solving a linear system that relates surface parameter space changes to screen space changes:

\begin{lstlisting}[language=C++]
// dpdx = dudx * dpdu + dvdx * dpdv
// dpdy = dudy * dpdu + dvdy * dpdv
SolveLinearSystem2x2(A, Bx, 
    &internal.dudx, &internal.dvdx);
SolveLinearSystem2x2(A, By, 
    &internal.dudy, &internal.dvdy);
\end{lstlisting}

\textbf{Test Scene:}

A demonstration scene \texttt{data/texture\_demo\_sphere.json} was created with:
\begin{itemize}
    \item Two spheres with different textures (image texture and checkerboard)
    \item 512$\times$512 resolution with 256 samples per pixel
    \item Successfully rendered to \texttt{texture\_demo\_output.exr}
\end{itemize}

\section{Results}

\subsection{Rendered Images}

Multiple test scenes have been successfully rendered demonstrating various features:

\begin{itemize}
    \item \textbf{Cornell Box with Refraction} (\texttt{cbox\_no\_light\_refract.exr}): Demonstrates perfect refraction material with glass objects
    \item \textbf{Rectangular Area Light Test} (\texttt{rect\_light\_test.exr}): Shows soft shadows from area lights
    \item \textbf{Texture Mapping Demo} (\texttt{texture\_demo\_output.exr}): Displays image textures and procedural patterns on spheres
    \item \textbf{Direct Lighting Test} (\texttt{test\_fixed.exr}): Validates basic direct lighting implementation
\end{itemize}

All images were rendered at a minimum resolution of 512$\times$512 with sufficient sampling (64-256 spp) for high quality anti-aliasing.

\subsection{Performance Analysis}

\begin{itemize}
    \item BVH acceleration provides orders of magnitude speedup over naive intersection testing
    \item Environment map importance sampling significantly reduces variance in scenes with bright HDR environments
    \item MIPMap reduces texture aliasing artifacts while maintaining interactive performance
    \item Multi-threading with OpenMP achieves near-linear scaling on multi-core processors
\end{itemize}

\subsection{Validation}

The implementation has been validated through:
\begin{itemize}
    \item Visual comparison with reference images
    \item Numerical verification of intersection algorithms
    \item Unit tests for core mathematical functions
    \item Scene-level integration testing with various material combinations
\end{itemize}

\section{Conclusion}

This project successfully implements a fully functional ray tracing renderer with all required features and several advanced optional features. The implementation demonstrates solid understanding of:

\begin{itemize}
    \item Geometric intersection algorithms
    \item Acceleration structures (BVH)
    \item Physically-based light transport
    \item Material modeling (diffuse, refractive)
    \item Advanced rendering techniques (environment lighting, texture mapping, area lights)
\end{itemize}

The modular design of the codebase allows for easy extension with additional features such as more complex BRDFs, participating media, or advanced sampling techniques.

\end{document}

